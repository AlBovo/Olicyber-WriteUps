#!/usr/bin/env python3
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from hashlib import sha1

g = 2
p = 128450990833487495239435278499085657422465092996722106047431474379143151314629045143653652944768444802270126846753537948967762324189664568189909545353158275858131431289893637086488338959187563881403307673553888146819064902112769916345947692089988589881442908285418049991125883165069766885822225248225468160077
B = 19169934253633570053953889246265820259461044627728742350375954893919588299072764293478579241179090085989239364059384650171921501824319820596779078772556266872211628082012734698934949168060761839895907838286248824705923322959869662359391820142687075587901345158396605310756769873886803959078844393091746849299
challenge = 56581528896983452515001967768248310545080265401766992662366067786016372851909638554447435589737014192896557318453781671822078909287435504086206205577004727253570958023360642429713834647404453446509100968023878907083686235506554652527774466716714231169976298056536775019633786807820118831080654365035445860396
A = 61831614541939305862040056876011264769936869285032469572218837781265288482033241791534990631225173290721375634351599902243630440637381714029745389387353897742573052717098998922091234692501269689365490524265256453299907543933174039541594657578172478976649845569933968153837378526430401432124019877984375895208
flag = bytes.fromhex("8d86c562e1296dbc9d383ad9c465dfb6bac904eb1ed913d8f4f6e36d2edc01e200c7ff4e710f0461a6ed68c3b755307efedae9097db0832ff6e4975f5ba168fe8ebc71a2dcabc4131abc9763c5f72a1c")

# challenge = (B * sa) % p quindi per trovare sa dobbiamo moltiplicare per l'inverso modulare di B (aka dividere per B se fosse challenge = B * sa)
sa = (challenge * pow(B, -1, p)) % p

shared = (A * sa) % p
cipher = AES.new(sha1(shared.to_bytes(128, byteorder = 'big')).digest()[:16], AES.MODE_ECB)
dec = unpad(cipher.decrypt(flag), 16)
print(dec)